public class BackTrack {
    /**
     * 如何判断一题目是否用回溯可以看两点
     * 首先回溯法时间复杂度很高，接近穷举，因此可以使用回溯的题目，输入nums.length肯定比较小
     * 其次，要能写出回溯树，才可以进行回溯，因此回溯题一定要把回溯树给写出来
     *
     * 回溯法需要找到以下内容才能顺利解题
     * 1. 可选路径，可选路径是指接下来要在哪些内容里进行选择，对于可选路径，有的题目每次都是从头遍历
     * 有的题目每次遍历都是上一个位置之后的位置来避免重复，因此递归参数里要考虑startIndex是否需要每次变化
     * 2. 当前路径，依次遍历可选路径，需要将符合条件的值插入当前路径，对于数字问题，当前路径用Stack来保存
     * 对于字符串问题，则用StringBuffer来保存
     * 3. 对于一个元素是否能加入当前路径，负责的题目会出现，对于当前路径不同的选择，之后进行不同的递归处理
     * 4. 知道何时进行下一轮递归，注意递归出口都是写在递归体最前面的部分，不满足递归出口才能遍历可选路径，进入
     * 下一次递归，对于递归出口的判断，可以很好的减少处理时间
     * 5.遍历可选路径时，有时候也可以进行递归return剪枝
     * 6.有一次往当前路径的add操作，就对应依次remove操作，这里的add，remove不一定都在递归前后
     * 也有可能是先add然后加入最终路径，加入后再remove，然后再return递归
     * 7。 对于stack注意，因此要保存到res中，所以res.add(new ArrayList<>(Stack)),但是对于StringBuffer
     * 直接add(sb.toString)
     * 8. 最主要的难点是可选路径的选择以及遍历，最后是实时的add和remove，
     *
     */
}
